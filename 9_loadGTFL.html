<!DOCTYPE html>
<html>
<<<<<<< HEAD
	<head>
    <title>loading glTF mesh + textures</title>
	</head>
	<body>
=======
  <head>
    <title>loading glTF mesh + textures</title>
  </head>
  <body>
>>>>>>> b460534067c0d0b2f3f5dfeebd45aa2a78592050
    
   <script type="module">

      import * as THREE from './js/build/three.module.js'
      import { OrbitControls } from './js/examples/jsm/controls/OrbitControls.js'
      
      import { GLTFLoader } from './js/examples/jsm/loaders/GLTFLoader.js';
<<<<<<< HEAD
			import { RGBELoader } from './js/examples/jsm/loaders/RGBELoader.js';

			let camera, scene, renderer, controls;

			init();
			render();

			function init() {

				const container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );
			

				scene = new THREE.Scene();
=======
      import { RGBELoader } from './js/examples/jsm/loaders/RGBELoader.js';

      let camera, scene, renderer, controls;

      const geometry2 = new THREE.SphereGeometry(0.75, 32, 32); //radius, resX, resY
      const material2 = new THREE.MeshPhongMaterial();
      const sphere = new THREE.Mesh(geometry2, material2);
      sphere.position.x = -2; //move it to the left
      scene.add(sphere);

      init();
      render();

      function init() {

        const container = document.createElement( 'div' );
        document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 0.25, 20 );

        scene = new THREE.Scene();
>>>>>>> b460534067c0d0b2f3f5dfeebd45aa2a78592050

        //the frameArea is from from https://threejsfundamentals.org/threejs/lessons/threejs-load-obj.html 
        function frameArea(sizeToFitOnScreen, boxSize, boxCenter, camera) {
          const halfSizeToFitOnScreen = sizeToFitOnScreen * 0.5;
          const halfFovY = THREE.MathUtils.degToRad(camera.fov * .5);
          const distance = halfSizeToFitOnScreen / Math.tan(halfFovY);
          // compute a unit vector that points in the direction the camera is now
          // in the xz plane from the center of the box
          const direction = (new THREE.Vector3())
            .subVectors(camera.position, boxCenter)
            .multiply(new THREE.Vector3(1, 0, 1))
            .normalize();

          // move the camera to a position distance units way from the center
          // in whatever direction the camera was from the center already
          camera.position.copy(direction.multiplyScalar(distance).add(boxCenter));

          // pick some near and far values for the frustum that
          // will contain the box.
          camera.near = boxSize / 100;
          camera.far = boxSize * 100;

          camera.updateProjectionMatrix();

          // point the camera to look at the center of the box
          camera.lookAt(boxCenter.x, boxCenter.y, boxCenter.z);
        }
        
        new RGBELoader()
<<<<<<< HEAD
					.setDataType( THREE.UnsignedByteType )
					.setPath( 'gltfs/DamagedHelmet/' )
					.load( 'royal_esplanade_1k.hdr', function ( texture ) {

          /*
						const envMap = pmremGenerator.fromEquirectangular( texture ).texture;

						scene.background = envMap;
						scene.environment = envMap;

						texture.dispose();
						pmremGenerator.dispose();
          */

						render();

						// model

				//		const loader = new GLTFLoader().setPath( 'gltfs/DamagedHelmet/' );
				//		loader.load( 'Helmet.txt', function ( gltf ) {

//            const loader = new GLTFLoader().setPath( 'gltfs/antiqueCamera/' );
//						loader.load( 'AntiqueCamera.gltf', function ( gltf ) {
            const loader = new GLTFLoader().setPath( 'gltfs/Scene/' );
						loader.load( 'scene.gltf', function ( gltf ) {

              scene.add( gltf.scene );

              // compute the box that contains all the stuff
              // from root and below
              const box = new THREE.Box3().setFromObject(gltf.scene);

              const boxSize = box.getSize(new THREE.Vector3()).length();
              const boxCenter = box.getCenter(new THREE.Vector3());

              // set the camera to frame the box
              frameArea(boxSize * 1.2, boxSize, boxCenter, camera);

              // update the controls to handle the new size
              controls.target.copy(boxCenter);
              controls.update();

						} );

					} );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
      
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				container.appendChild( renderer.domElement );

				const pmremGenerator = new THREE.PMREMGenerator( renderer ); //PMREM  = Prefiltered, Mipmapped Radiance Environment Map
				pmremGenerator.compileEquirectangularShader();

				controls = new OrbitControls( camera, renderer.domElement );
				controls.addEventListener( 'change', render ); // use if there is no animation loop
			}


			function render() {        
				renderer.render( scene, camera );
			}
      
      
      
		</script>
	</body>
=======
        .setDataType( THREE.UnsignedByteType )
      
        const loader = new GLTFLoader().setPath( 'gltf/' );
        loader.load( 'scene.gltf', function ( gltf ) {

          scene.add( gltf.scene );

          // compute the box that contains all the stuff
          // from root and below
          const box = new THREE.Box3().setFromObject(gltf.scene);

          const boxSize = box.getSize(new THREE.Vector3()).length();
          const boxCenter = box.getCenter(new THREE.Vector3());

          // set the camera to frame the box
          frameArea(boxSize * 1.2, boxSize, boxCenter, camera);

          // update the controls to handle the new size
          controls.target.copy(boxCenter);
          controls.update();

          render()

      } );


        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
      
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputEncoding = THREE.sRGBEncoding;
        container.appendChild( renderer.domElement );

        const pmremGenerator = new THREE.PMREMGenerator( renderer ); //PMREM  = Prefiltered, Mipmapped Radiance Environment Map
        pmremGenerator.compileEquirectangularShader();

        controls = new OrbitControls( camera, renderer.domElement );
        controls.addEventListener( 'change', render ); // use if there is no animation loop
      }

      function render() {        
        renderer.render( scene, camera );
      }
      
      
      
    </script>
  </body>
>>>>>>> b460534067c0d0b2f3f5dfeebd45aa2a78592050
</html>